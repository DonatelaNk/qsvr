/************************************************************************************

DepthKit Unity SDK License v1
Copyright 2016-2017 Depth Kit Inc. All Rights reserved.  

Licensed under the Depth Kit Inc. Software Development Kit License Agreement (the "License"); 
you may not use this SDK except in compliance with the License, 
which is provided at the time of installation or download, 
or which otherwise accompanies this software in either electronic or hard copy form.  

You may obtain a copy of the License at http://www.depthkit.tv/license-agreement-v1

Unless required by applicable law or agreed to in writing, 
the SDK distributed under the License is distributed on an "AS IS" BASIS, 
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
See the License for the specific language governing permissions and limitations under the License. 

************************************************************************************/

using UnityEngine;
using System.Collections;

namespace DepthKit
{
    [ExecuteInEditMode]
    /// <summary>
    /// The base class that any DepthKit Renderer implementation will derrive from 
    /// </summary>
    /// <remarks>
    /// This class provides methods that are implemented in child classes to allow
    /// a way for clip to be rendered in different ways
    /// </remarks>
    public abstract class ClipRenderer : MonoBehaviour
    {
        public enum MeshDensity
        {
            High,
            Medium,
            Low
        };

        protected bool _geometryDirty;
        protected bool _materialDirty;
        protected bool _textureUpdated;
        protected bool _metadataChanged;

        /// <summary>
        /// Texture that represents the current frame
        /// <summary>
        protected Texture _texture;
        // use the public getter/setter only when we need to mark the mesh dirty
        public Texture Texture
        {
            get { return _texture; }
            set
            {
                _textureUpdated = true; // use this flag if you need it
                _texture = value;
            }
        }

        /// <summary>
        /// Set to true if the Texture is flipped from what default unity Textures would expect
        /// <summary>
        protected bool _textureIsFlipped;
        // use the public getter/setter only when we need to mark the mesh dirty
        public bool TextureIsFlipped
        {
            get { return _textureIsFlipped; }
            set
            {
                _materialDirty = (_textureIsFlipped != value);
                _textureIsFlipped = value;
            }
        }

        /// <summary>
        /// Set to true if the Texture is generated by a source that does not automatically apply gamma
        /// <summary>
        protected bool _textureIsExternal;
        public bool TextureIsExternal
        {
            get { return _textureIsExternal; }
            set
            {
                _materialDirty = (_textureIsExternal != value);
                _textureIsExternal = value;
            }
        }

        /// <summary>
        /// Texture placeholder for edit mode
        /// <summary>
        [SerializeField, HideInInspector]
        protected Texture2D _poster;
        // use the public getter/setter only when we need to mark the mesh dirty
        public Texture2D Poster
        {
            get { return _poster; }
            set
            {
                _poster = value;
            }
        }

        /// <summary>
        /// Metadata contains information about the current clip
        /// <summary>
        [SerializeField, HideInInspector]
        protected Metadata _metadata;
        // use the public getter/setter only when we need to mark the mesh dirty
        public Metadata Metadata
        {
            get { return _metadata; }
            set
            {
                _geometryDirty = true;
                _metadataChanged = true;
                _metadata = value;
            }
        }

        [HideInInspector]
        public float _depthPackingEpsilon;
        [HideInInspector]
        public float _depthSaturationThreshold;
        [HideInInspector]
        public float _depthBrightnessThreshold;


        public void SetGeometryDirty()
        {
            _geometryDirty = true;
        }

        public void SetMaterialDirty()
        {
            _materialDirty = true;
        }

        /// <summary>
        /// Render type returns the appropriate enum for each subclass implementation
        /// <summary>
        public abstract RenderType GetRenderType();

        /// <summary>
        /// Cleans the scene of all scripts and game objects generated by this renderer
        /// <summary>
        public abstract void RemoveComponents();

        /// <summary>
        /// Sets all the parameters on materials built using the DepthKit.cginc convenience functions
        /// call this from the subclasses
        /// <summary>
        protected virtual void SetMaterialProperties(Material material)
        {
            if (material == null || _metadata == null)
            {
                return;
            }

            if (Application.isPlaying)
            {
                material.SetTexture("_MainTex", _texture);
                material.SetTexture("_MainTex2", _texture);
                material.SetInt("_TextureFlipped", _textureIsFlipped ? 1 : 0);
                material.SetInt("_ExternalTexture", _textureIsExternal ? 1 : 0);
            }
            else if (!Application.isPlaying && _poster != null)
            {
                material.SetTexture("_MainTex", _poster);
                material.SetTexture("_MainTex2", _poster);
                material.SetInt("_TextureFlipped", 0);
                material.SetInt("_NativeTexture", 0);
            }
            else
            {
                material.SetTexture("_MainTex", null);
                material.SetTexture("_MainTex2", null);
                material.SetInt("_TextureFlipped", 0);
                material.SetInt("_NativeTexture", 0);
            }

            //dynamic color space switching
            material.SetInt("_LinearColorSpace", QualitySettings.activeColorSpace == ColorSpace.Linear ? 1 : 0);

            material.SetVector("_TextureDimensions", new Vector4(_metadata.textureWidth, _metadata.textureHeight, 0.0f, 0.0f));
            material.SetFloat("_Cutoff", .8f); // TODO: required??

            //tweak props
            material.SetFloat("_Epsilon", _depthPackingEpsilon);
            material.SetFloat("_DepthSaturationThreshhold", _depthSaturationThreshold);
            material.SetFloat("_DepthBrightnessThreshold",_depthBrightnessThreshold);

            // only supporting 1 perspective for now, can extend for multi-perspective in the future
            if (_metadata.perspectives != null && _metadata.perspectives.Length >= 1)
            {
                var perspective = _metadata.perspectives[0];
                material.SetVector("_Crop", perspective.crop);
                material.SetVector("_ImageDimensions", perspective.depthImageSize);
                material.SetVector("_FocalLength", perspective.depthFocalLength);
                material.SetVector("_PrincipalPoint", perspective.depthPrincipalPoint);
                material.SetFloat("_NearClip", perspective.nearClip);
                material.SetFloat("_FarClip", perspective.farClip);
                material.SetMatrix("_Extrinsics", perspective.extrinsics);
            }
        }
    }
}